// ==========================================
// ã€è¨­å®šå€ã€‘
// ==========================================
const CALENDAR_ID_A = 'sjstw.com@gmail.com'; 
const CALENDAR_ID_B = '608ca8755f1bc7e02cfea67c361989797cf2a526949d2dc052e5e81fef302eee@group.calendar.google.com'; 
// â˜… æ–°å¢ï¼šç¬¬ä¸‰ä½å¸«å‚… (Peter)
const CALENDAR_ID_C = 'peter750529@gmail.com'; 

const SHEET_ID = '1eRLeHawrTiAnHuenTAOhRkvnELrWNTP8OjwPpFt0xSU'; 
const FOLDER_ID = '1DCDNBAVn1Bo--Zgei9SSwtW2rqbRYwNE'; 
const BOSS_EMAIL = 'sjstw.com@gmail.com'; 
const LINE_CHANNEL_TOKEN = '70EMo6PqOKwX38elQENYLKktnTBShZvNLZ64fyMKwMTLmj2tJn3p7rddWfvmR8RMBEHCZvY+fnEllGT9pMVK6/2WLPTwkZQycOcc6lp9FwXScukMAJPLPJlKu2+PuVwxVhAJw7UtC/lxULmt3Z3/ZwdB04t89/1O/w1cDnyilFU='; 

// â˜… ä¿®æ”¹ï¼šæœå‹™ç›®éŒ„æ”¯æ´ C
// å¦‚æœæ‚¨æœ‰å°ˆå±¬æ–¼ Peter çš„å·¥ä½œï¼Œè«‹å¡«å…¥ Cï¼Œå¦å‰‡ä¿æŒç©ºæˆ–è‡ªè¡Œèª¿é…
const CATALOG = {
  'A': { 'ac_split': {time:60}, 'ac_window': {time:120}, 'ac_hidden': {time:120}, 'ac_4way': {time:150}, 'wash_top': {time:90}, 'wash_drum': {time:180} },
  'B': { 'bath': {time:210}, 'bed_1': {time:180}, 'bed_2': {time:180}, 'sofa_1': {time:120}, 'sofa_2': {time:120}, 'sofa_all': {time:120}, 'mite_home': {time:60}, 'mite_sofa_1': {time:60}, 'mite_sofa_2': {time:60}, 'mite_sofa_l': {time:60}, 'mite_bed_1': {time:60}, 'mite_bed_2': {time:60} },
  'C': { 
      // ç¯„ä¾‹ï¼šå¦‚æœä»¥å¾Œæœ‰å°ˆå±¬æ–¼ Peter çš„é …ç›®ï¼Œå¯ä»¥æ”¾é€™è£¡
      // 'special_cleaning': {time: 60} 
  }
};

function doGet(e) {
  if (e.parameter.action) return handleApproval(e);
  return ContentService.createTextOutput("System Active");
}

function doPost(e) {
  var lock = LockService.getScriptLock();
  if (lock.tryLock(10000)) {
    try {
      const params = JSON.parse(e.postData.contents);
      if (params.action === 'getBusySchedule') return out(getBusySchedule(params.year, params.month, params.items));
      if (params.action === 'getSlots') return out(getAvailableSlots(params.date, params.items));
      if (params.action === 'submitOrder') return out(submitOrder(params));
    } catch (err) { return out({status: "error", msg: err.toString()}); } 
    finally { lock.releaseLock(); }
  } else return out({status: "error", msg: "ç³»çµ±å¿™ç¢Œä¸­"});
}
function out(data){ return ContentService.createTextOutput(JSON.stringify(data)).setMimeType(ContentService.MimeType.JSON); }

function getShortUrl(longUrl) {
  try {
    const response = UrlFetchApp.fetch("https://is.gd/create.php?format=simple&url=" + encodeURIComponent(longUrl));
    return response.getResponseCode() === 200 ? response.getContentText() : longUrl;
  } catch (e) { return longUrl; }
}

// ----------------------------------------------------
// éš±ç§èˆ‡å€åŸŸè§£æ
// ----------------------------------------------------
function parseRegion(title) {
  let matches = title.match(/\[(.*?)\]/); 
  if (!matches) return null;
  let fullContent = matches[1]; 
  const systemStatus = ['å¾…æ ¸å‡†', 'å·²é ç´„', 'å·²ç¢ºèª', 'å·²æ‹’çµ•'];
  if (systemStatus.includes(fullContent)) return null;
  
  let standardMatch = fullContent.match(/(..[ç¸£å¸‚])(..+[å€é„‰é®å¸‚])/);
  if (standardMatch) return standardMatch[0];

  let otherMatch = fullContent.match(/(..+[ç¸£å¸‚])(..+[å€é„‰é®å¸‚])/);
  if (otherMatch) return otherMatch[0];

  if (fullContent.includes("å…¶ä»–ç¸£å¸‚")) return "å…¶ä»–ç¸£å¸‚";

  return fullContent.substring(0, 6); 
}

// ----------------------------------------------------
// â˜… ä¿®æ”¹ï¼šè®€å–è¡Œç¨‹ (æ”¯æ´ A, B, C)
// ----------------------------------------------------
function getBusySchedule(year, month, items) {
  const calA = CalendarApp.getCalendarById(CALENDAR_ID_A);
  const calB = CalendarApp.getCalendarById(CALENDAR_ID_B);
  const calC = CalendarApp.getCalendarById(CALENDAR_ID_C); // â˜… æ–°å¢
  
  let dur = calculateDuration(items);
  // è§£æ§‹å–å¾— A, B, C çš„æ™‚é–“
  let timeA = dur.timeA, timeB = dur.timeB, timeC = dur.timeC;

  const start = new Date(year, month, 1);
  const end = new Date(year, month + 1, 0); 
  
  // ä¸€æ¬¡æ’ˆå–æ•´å€‹æœˆçš„äº‹ä»¶
  const allEventsA = calA.getEvents(start, end);
  const allEventsB = calB.getEvents(start, end);
  const allEventsC = calC.getEvents(start, end); // â˜… æ–°å¢
  
  let scheduleMap = {};
  
  for (let d = 1; d <= end.getDate(); d++) {
    let currentDay = new Date(year, month, d);
    let dateStr = Utilities.formatDate(currentDay, 'Asia/Taipei', 'yyyy-MM-dd');
    
    let dayEventsA = allEventsA.filter(e => isSameDay(e.getStartTime(), currentDay));
    let dayEventsB = allEventsB.filter(e => isSameDay(e.getStartTime(), currentDay));
    let dayEventsC = allEventsC.filter(e => isSameDay(e.getStartTime(), currentDay)); // â˜… æ–°å¢
    
    let regions = [];
    // åˆä½µ A, B, C çš„è¡Œç¨‹ä¾†æŠ“å–åœ°å€
    [...dayEventsA, ...dayEventsB, ...dayEventsC].forEach(e => {
       let r = parseRegion(e.getTitle());
       if (r && !regions.includes(r)) regions.push(r);
    });

    // å‚³å…¥ C çš„äº‹ä»¶èˆ‡æ™‚é–“
    let slots = calculateDailySlots(currentDay, dayEventsA, dayEventsB, dayEventsC, timeA, timeB, timeC);
    
    scheduleMap[dateStr] = {
      regions: regions,
      hasSlot: slots.length > 0
    };
  }
  return scheduleMap;
}

function isSameDay(d1, d2) {
  return d1.getFullYear() === d2.getFullYear() && 
         d1.getMonth() === d2.getMonth() && 
         d1.getDate() === d2.getDate();
}

// ----------------------------------------------------
// â˜… ä¿®æ”¹ï¼šè¨ˆç®—æ‰€éœ€æ™‚é–“ (æ”¯æ´ C)
// ----------------------------------------------------
function calculateDuration(items) {
  let timeA = 0, timeB = 0, timeC = 0; // â˜… æ–°å¢ timeC
  if(items) {
    for (let key in items) {
      if (items[key] > 0) {
        if (CATALOG.A[key]) timeA += CATALOG.A[key].time * items[key];
        else if (CATALOG.B[key]) timeB += CATALOG.B[key].time * items[key];
        else if (CATALOG.C && CATALOG.C[key]) timeC += CATALOG.C[key].time * items[key]; // â˜… åˆ¤æ–· C
      }
    }
  }
  // å¦‚æœæœ‰è©²é¡åˆ¥çš„å·¥å–®ï¼ŒåŠ ä¸Š 30 åˆ†é˜ç·©è¡
  if (timeA > 0) timeA += 30;
  if (timeB > 0) timeB += 30;
  if (timeC > 0) timeC += 30;
  
  return { timeA, timeB, timeC };
}

// ----------------------------------------------------
// â˜… ä¿®æ”¹ï¼šå–å¾—å–®æ—¥ç©ºæª” (æ”¯æ´ C)
// ----------------------------------------------------
function getAvailableSlots(dateStr, items) {
  const calA = CalendarApp.getCalendarById(CALENDAR_ID_A);
  const calB = CalendarApp.getCalendarById(CALENDAR_ID_B);
  const calC = CalendarApp.getCalendarById(CALENDAR_ID_C); // â˜… æ–°å¢
  const date = new Date(dateStr.replace(/-/g, '/'));
  
  let dur = calculateDuration(items);
  const eventsA = calA.getEventsForDay(date);
  const eventsB = calB.getEventsForDay(date);
  const eventsC = calC.getEventsForDay(date); // â˜… æ–°å¢
  
  let availableSlots = calculateDailySlots(date, eventsA, eventsB, eventsC, dur.timeA, dur.timeB, dur.timeC);
  
  // å›å‚³ä¹Ÿè¦åŒ…å« C çš„æ™‚é–“ï¼Œé›–ç„¶å‰ç«¯å¯èƒ½ç›®å‰æ²’ç”¨åˆ°ï¼Œä½†ä¿æŒçµæ§‹å®Œæ•´
  return { slots: availableSlots, timeA: dur.timeA, timeB: dur.timeB, timeC: dur.timeC };
}

// ----------------------------------------------------
// â˜… ä¿®æ”¹ï¼šæ ¸å¿ƒç©ºæª”è¨ˆç®— (æ”¯æ´ C)
// ----------------------------------------------------
function calculateDailySlots(date, eventsA, eventsB, eventsC, timeA, timeB, timeC) {
  const dayOfWeek = date.getDay();
  const lastHour = (dayOfWeek >= 1 && dayOfWeek <= 5) ? 14 : 18;
  
  let availableSlots = [];
  
  for (let h = 9; h <= lastHour; h++) {
    let isPriority = (h % 2 !== 0); 
    let isGapFiller = false;
    
    // Gap Filling: æª¢æŸ¥ A, B, C ä»»ä¸€äººæ˜¯å¦å‰›å¥½åœ¨æ•´é»çµæŸ
    if (timeA > 0) {
        for(let ev of eventsA) {
            let evEnd = ev.getEndTime();
            if (evEnd.getHours() === h && evEnd.getMinutes() <= 15) isGapFiller = true;
        }
    }
    if (timeB > 0) {
        for(let ev of eventsB) {
            let evEnd = ev.getEndTime();
            if (evEnd.getHours() === h && evEnd.getMinutes() <= 15) isGapFiller = true;
        }
    }
    // â˜… æª¢æŸ¥ C çš„ç©ºæª”
    if (timeC > 0) {
        for(let ev of eventsC) {
            let evEnd = ev.getEndTime();
            if (evEnd.getHours() === h && evEnd.getMinutes() <= 15) isGapFiller = true;
        }
    }

    if (isPriority || isGapFiller) {
        let slotOkA = true, slotOkB = true, slotOkC = true; // â˜… æ–°å¢ slotOkC
        let slotStart = new Date(date); slotStart.setHours(h, 0, 0);

        // æª¢æŸ¥ A
        if (timeA > 0) {
          let slotEnd = new Date(slotStart); slotEnd.setMinutes(slotStart.getMinutes() + timeA);
          if (slotStart.getHours() > lastHour) slotOkA = false;
          if (eventsA.some(e => isOverlap(slotStart, slotEnd, e))) slotOkA = false;
        }

        // æª¢æŸ¥ B
        if (timeB > 0) {
          let slotEnd = new Date(slotStart); slotEnd.setMinutes(slotStart.getMinutes() + timeB);
          if (slotStart.getHours() > lastHour) slotOkB = false;
          if (eventsB.some(e => isOverlap(slotStart, slotEnd, e))) slotOkB = false;
        }

        // â˜… æª¢æŸ¥ C
        if (timeC > 0) {
          let slotEnd = new Date(slotStart); slotEnd.setMinutes(slotStart.getMinutes() + timeC);
          if (slotStart.getHours() > lastHour) slotOkC = false;
          if (eventsC.some(e => isOverlap(slotStart, slotEnd, e))) slotOkC = false;
        }

        // åªæœ‰ç•¶æ‰€æœ‰éœ€è¦çš„å¸«å‚…éƒ½æœ‰ç©ºæ™‚ï¼Œæ‰é–‹æ”¾è©²æ™‚æ®µ
        if (slotOkA && slotOkB && slotOkC) {
          let labelRaw = `${h}`.padStart(2, '0') + `:00`;
          let period = h >= 12 ? (h==12?'ä¸­åˆ':'ä¸‹åˆ') : 'ä¸Šåˆ';
          availableSlots.push({ time: labelRaw, label: `${period} ${labelRaw}` });
        }
    }
  }
  return availableSlots;
}

function isOverlap(s1, e1, evt) { return (s1 < evt.getEndTime() && e1 > evt.getStartTime()); }

// ----------------------------------------------------
// â˜… ä¿®æ”¹ï¼šæäº¤è¨‚å–® (è™•ç† C çš„äº‹ä»¶å»ºç«‹)
// ----------------------------------------------------
function submitOrder(data) {
  try {
    const calA = CalendarApp.getCalendarById(CALENDAR_ID_A);
    const calB = CalendarApp.getCalendarById(CALENDAR_ID_B);
    const calC = CalendarApp.getCalendarById(CALENDAR_ID_C); // â˜… æ–°å¢
    
    const sheet = SpreadsheetApp.openById(SHEET_ID).getSheets()[0];
    const orderId = Utilities.formatDate(new Date(), 'Asia/Taipei', 'yyyyMMddHHmmss');
    
    let fileLinks = [];
    let emailAttachments = [];
    if (data.images && data.images.length > 0) {
      const folder = DriveApp.getFolderById(FOLDER_ID).createFolder(`${orderId}_${data.name}`);
      data.images.forEach((img, idx) => {
        let type = img.substring(5, img.indexOf(';'));
        let bytes = Utilities.base64Decode(img.substr(img.indexOf('base64,')+7));
        let blob = Utilities.newBlob(bytes, type, `photo_${idx+1}.jpg`);
        folder.createFile(blob).setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW);
        fileLinks.push(folder.getFiles().next().getUrl());
        emailAttachments.push(blob);
      });
    }
    const photoLinkStr = fileLinks.length > 0 ? fileLinks.join('\n') : "ç„¡";
    
    let finalAddress = (data.city === "å…¶ä»–ç¸£å¸‚" || !data.district || data.district === "ç„¡") ? data.address : `${data.city}${data.district}${data.address}`;
    let cleanRegion = "";
    if (data.city === "å…¶ä»–ç¸£å¸‚") {
         let match = data.address.match(/(..+[ç¸£å¸‚])(..+[å€é„‰é®å¸‚])/);
         if(match) cleanRegion = `${match[1]} ${match[2]}`; 
         else cleanRegion = data.address.substring(0,6);
    } else {
         if (data.district === "ç„¡" || !data.district) cleanRegion = data.city;
         else cleanRegion = `${data.city} ${data.district}`; 
    }

    let approvalData = [];
    // æ‰¾å‡ºä¸‰å€‹å¸«å‚…ä¸­æ™‚é–“æœ€é•·çš„
    let duration = Math.max(data.timeA, data.timeB, data.timeC || 0) || 60;
    let remarks = data.remarks || "ç„¡"; 

    data.selectedSlots.forEach((slot, index) => {
      let priority = index + 1;
      let startTime = new Date(slot.date.replace(/-/g, '/') + ' ' + slot.time);
      let nextYearDate = new Date(startTime); nextYearDate.setDate(nextYearDate.getDate() + 365);
      let nextYearStr = Utilities.formatDate(nextYearDate, 'Asia/Taipei', 'yyyy-MM-dd');

      let title = `[${cleanRegion}]${data.name}(é †ä½${priority})`;
      let desc = `è¨‚å–®: ${orderId}\né›»è©±: ${data.phone}\né …ç›®: ${data.summary}\nç¸½åƒ¹: ${data.totalPrice}\nå‚™è¨»: ${remarks}\nå®Œæ•´åœ°å€: ${finalAddress}`;
      
      let eventIds = [];
      // è™•ç† A
      if (data.timeA > 0) {
        let endTime = new Date(startTime.getTime() + data.timeA * 60000);
        let evt = calA.createEvent(title, startTime, endTime, { location: finalAddress, description: desc });
        evt.setColor(CalendarApp.EventColor.YELLOW);
        eventIds.push({cal:'A', id:evt.getId()});
      }
      // è™•ç† B
      if (data.timeB > 0) {
        let endTime = new Date(startTime.getTime() + data.timeB * 60000);
        let evt = calB.createEvent(title, startTime, endTime, { location: finalAddress, description: desc + "\n(å”åŠ©A)" });
        evt.setColor(CalendarApp.EventColor.YELLOW);
        eventIds.push({cal:'B', id:evt.getId()});
      }
      // â˜… è™•ç† C
      if (data.timeC && data.timeC > 0) {
        let endTime = new Date(startTime.getTime() + data.timeC * 60000);
        let evt = calC.createEvent(title, startTime, endTime, { location: finalAddress, description: desc + "\n(å”åŠ©/å…¶ä»–)" });
        evt.setColor(CalendarApp.EventColor.YELLOW);
        eventIds.push({cal:'C', id:evt.getId()});
      }
      
      approvalData.push({ 
        priority: priority, 
        date: slot.date, 
        time: slot.time, 
        eventIds: eventIds,
        isRec: slot.isRec 
      });

      sheet.appendRow([
        orderId, new Date(), priority, "'"+slot.date, "'"+slot.time, data.name, "'" + data.phone, 
        finalAddress, data.summary, data.totalPrice, 'å¾…æ ¸å‡†', nextYearStr, data.userId, photoLinkStr, remarks 
      ]);
    });

    sendApprovalEmail(data, approvalData, emailAttachments, finalAddress, orderId, duration, remarks, data.city);
    return { status: 'success' };
  } catch (e) { return { status: 'error', msg: e.toString() }; }
}

// ----------------------------------------------------
// â˜… ä¿®æ”¹ï¼šæ ¸å‡†/æ‹’çµ• (æ”¯æ´ C çš„äº‹ä»¶è™•ç†)
// ----------------------------------------------------
function handleApproval(e) {
  var lock = LockService.getScriptLock();
  if (!lock.tryLock(5000)) return createHtmlOutput("âš ï¸ ç³»çµ±è™•ç†ä¸­...", "warning");
  try {
    const action = e.parameter.action;
    let slotsData, info;
    try { slotsData = JSON.parse(decodeURIComponent(e.parameter.data)); info = JSON.parse(decodeURIComponent(e.parameter.info)); } catch(err) { return createHtmlOutput("âŒ è³‡æ–™è§£æå¤±æ•—", "error"); }
    let msg = "", targetUserId = null, orderId = info.orderId;
    if (action === 'approve') {
      const targetIdx = parseInt(e.parameter.target);
      const approvedSlot = slotsData[targetIdx];
      targetUserId = updateSheetStatusByOrderId(orderId, approvedSlot.date, approvedSlot.time, 'approve');
      if (targetUserId === 'ALREADY_APPROVED') return createHtmlOutput("âš ï¸ æ­¤è¨‚å–®å…ˆå‰å·²ç¶“æ ¸å‡†éäº†ã€‚", "info");
      const finalTitle = `[${info.region}] [å·²é ç´„] ${info.name}`;
      slotsData.forEach((slot, idx) => {
        let isApproved = (idx === targetIdx);
        slot.eventIds.forEach(ev => { 
            try { 
                // â˜… é€™è£¡åŠ å…¥åˆ¤æ–· C
                let cal;
                if (ev.cal === 'A') cal = CalendarApp.getCalendarById(CALENDAR_ID_A);
                else if (ev.cal === 'B') cal = CalendarApp.getCalendarById(CALENDAR_ID_B);
                else if (ev.cal === 'C') cal = CalendarApp.getCalendarById(CALENDAR_ID_C); // â˜… æ–°å¢

                let evt = cal.getEventById(ev.id); 
                if (evt) { 
                    if (isApproved) { 
                        evt.setTitle(finalTitle); 
                        evt.setColor(CalendarApp.EventColor.GREEN); 
                    } else evt.deleteEvent(); 
                } 
            } catch(calErr) {} 
        });
      });
      msg = `âœ… è¨‚å–® ${orderId} æ ¸å‡†æˆåŠŸ`;
      if (targetUserId) {
        let calLink = createCalendarLink(`é ç´„æ¸…æ½”: ${info.name}`, approvedSlot.date, approvedSlot.time, info.duration || 60, info.region, info.summary);
        let success = pushLineFlexMessage(targetUserId, `é ç´„ç¢ºèªï¼š${info.name}`, approvedSlot.date, approvedSlot.time, info.region, info.summary, calLink);
        msg += success ? "<br>(LINEå·²ç™¼é€)" : "<br>(ç™¼é€å¤±æ•—)";
      }
    } else if (action === 'reject_all') {
      targetUserId = updateSheetStatusByOrderId(orderId, null, null, 'reject_all');
      if (targetUserId === 'ALREADY_APPROVED') return createHtmlOutput("âš ï¸ æ­¤è¨‚å–®å·²è™•ç†éã€‚", "info");
      slotsData.forEach(slot => { 
          slot.eventIds.forEach(ev => { 
              try { 
                // â˜… é€™è£¡åŠ å…¥åˆ¤æ–· C
                let cal;
                if (ev.cal === 'A') cal = CalendarApp.getCalendarById(CALENDAR_ID_A);
                else if (ev.cal === 'B') cal = CalendarApp.getCalendarById(CALENDAR_ID_B);
                else if (ev.cal === 'C') cal = CalendarApp.getCalendarById(CALENDAR_ID_C); // â˜… æ–°å¢

                let evt = cal.getEventById(ev.id); 
                if(evt) evt.deleteEvent(); 
              } catch(e){} 
          }); 
      });
      msg = `âŒ è¨‚å–® ${orderId} å·²æ‹’çµ•`;
      if (targetUserId) pushLineMessage(targetUserId, `ã€é ç´„é€šçŸ¥ã€‘${info.name}æ‚¨å¥½ï¼Œå¾ˆæŠ±æ­‰æ‚¨ç”³è«‹çš„æ™‚æ®µçš†å·²é¡æ»¿ï¼Œè«‹é‡æ–°é ç´„å…¶ä»–æ™‚æ®µã€‚`);
    }
    return createHtmlOutput(msg, "success");
  } catch (e) { return createHtmlOutput("Error: " + e.toString(), "error"); } 
  finally { lock.releaseLock(); }
}

// ... ä¿æŒ createHtmlOutput, createCalendarLink, updateSheetStatusByOrderId, pushLineMessage, pushLineFlexMessage, sendApprovalEmail, getMonthlyScheduleTableHtml, checkIsRecommended ä¸è®Š ...
// (ä»¥ä¸‹ç‚ºå…±ç”¨å‡½å¼ï¼Œç›´æ¥è¤‡è£½åŸæœ‰çš„å³å¯ï¼Œä½†ç‚ºäº†ç¢ºä¿å®Œæ•´æ€§ï¼Œæˆ‘å°‡å®ƒå€‘åˆ—åœ¨ä¸‹æ–¹)

function sendApprovalEmail(data, approvalData, emailAttachments, finalAddress, orderId, duration, remarks, userCity) {
  const scriptUrl = ScriptApp.getService().getUrl();
  const encodedData = encodeURIComponent(JSON.stringify(approvalData));
  const encodedInfo = encodeURIComponent(JSON.stringify({ name: data.name, region: finalAddress, orderId: orderId, summary: data.summary, duration: duration }));
  let targetDate = approvalData[0].date.replace(/-/g, '/');
  let calendarUrl = `https://calendar.google.com/calendar/u/0/r/month/${targetDate}`;
  const calendarTableHtml = getMonthlyScheduleTableHtml(approvalData);
  let buttons = approvalData.map((s, i) => {
    let rawLink = `${scriptUrl}?action=approve&target=${i}&data=${encodedData}&info=${encodedInfo}`;
    let shortLink = getShortUrl(rawLink); 
    let isRecommended = false;
    if (userCity && userCity !== 'å…¶ä»–ç¸£å¸‚') isRecommended = checkIsRecommended(s.date, userCity);
    let recommendIcon = isRecommended ? '<span style="background:red;color:white;border-radius:50%;padding:2px 6px;margin-right:5px;font-size:12px;">æ¨</span>' : '';
    return `<div style="margin:15px 0;padding:15px;border:1px solid #ddd;font-size:16px;">${recommendIcon}<b>é †ä½${s.priority}</b> ${s.date} ${s.time} <a href="${shortLink}" style="background:green;color:white;padding:8px 15px;text-decoration:none;border-radius:4px;margin-left:10px;">âœ… æ ¸å‡†æ­¤æ™‚æ®µ</a></div>`;
  }).join('');
  let rejectBtn = `<div style="margin-top:20px;font-size:16px;"><a href="${getShortUrl(`${scriptUrl}?action=reject_all&data=${encodedData}&info=${encodedInfo}`)}" style="background:red;color:white;padding:8px 15px;text-decoration:none;border-radius:4px;">âŒ å…¨éƒ¨æ‹’çµ•</a></div>`;
  MailApp.sendEmail({
    to: BOSS_EMAIL,
    subject: `ã€æ–°å–® ${orderId}ã€‘${data.name} - ${finalAddress}`,
    htmlBody: `<div style="font-family: sans-serif; font-size: 16px; color: #333;"><h2 style="color: #0056b3;">æ–°é ç´„ç”³è«‹</h2><p><b>è¨‚å–®:</b> ${orderId}</p><p><b>å®¢æˆ¶:</b> ${data.name}</p><p><b>é›»è©±:</b> <a href="tel:${data.phone}">${data.phone}</a></p><p><b>åœ°å€:</b> ${finalAddress}</p><p><b>é …ç›®:</b> ${data.summary} (ç¸½åƒ¹ $${data.totalPrice})</p><p style="background-color:#fff3cd; padding:10px; border-left: 5px solid #ffc107;"><b>å‚™è¨»:</b> ${remarks}</p><hr><h3>ğŸ“… æœªä¾† 30 å¤©è¡Œç¨‹ç¸½è¦½</h3><a href="${calendarUrl}" target="_blank" style="background-color:#4285F4; color:white; padding:10px 20px; text-decoration:none; border-radius:5px; font-weight:bold; display:inline-block; margin-bottom:15px; font-size:16px;">ğŸ“… é–‹å•Ÿ Google æ—¥æ›† (æœˆæª¢è¦–)</a><div style="background:#fff; padding:10px; border:1px solid #ddd; margin-top:10px;">${calendarTableHtml}</div><hr><h3>å¯©æ ¸æ“ä½œ</h3>${buttons}${rejectBtn}</div>`,
    attachments: emailAttachments
  });
}

function checkIsRecommended(dateStr, userCity) {
  if (!userCity) return false;
  const calA = CalendarApp.getCalendarById(CALENDAR_ID_A);
  const calB = CalendarApp.getCalendarById(CALENDAR_ID_B);
  // â˜… ä¿®æ”¹ï¼šæ¨è–¦æª¢æŸ¥ä¹Ÿè¦åŒ…å« C
  const calC = CalendarApp.getCalendarById(CALENDAR_ID_C); 
  const date = new Date(dateStr.replace(/-/g, '/'));
  const events = [...calA.getEventsForDay(date), ...calB.getEventsForDay(date), ...calC.getEventsForDay(date)];
  for (let e of events) {
    let region = parseRegion(e.getTitle());
    if (region && region.startsWith(userCity)) return true;
  }
  return false;
}

function getMonthlyScheduleTableHtml(approvalData) {
  const calA = CalendarApp.getCalendarById(CALENDAR_ID_A);
  const calB = CalendarApp.getCalendarById(CALENDAR_ID_B);
  // â˜… ä¿®æ”¹ï¼šè¡¨æ ¼ä¹Ÿè¦é¡¯ç¤º C çš„è¡Œç¨‹
  const calC = CalendarApp.getCalendarById(CALENDAR_ID_C); 
  const startDate = new Date(); startDate.setHours(0,0,0,0);
  const endDate = new Date(startDate); endDate.setDate(startDate.getDate() + 30);
  const events = [...calA.getEvents(startDate, endDate), ...calB.getEvents(startDate, endDate), ...calC.getEvents(startDate, endDate)];
  
  let pendingSet = new Set();
  if (approvalData) {
    approvalData.forEach(s => pendingSet.add(`${s.date} ${s.time}`));
  }

  let eventsByDate = {};
  events.forEach(e => {
    let dateKey = Utilities.formatDate(e.getStartTime(), 'Asia/Taipei', 'yyyy-MM-dd');
    let timeStr = Utilities.formatDate(e.getStartTime(), 'Asia/Taipei', 'HH:mm');
    let title = e.getTitle();
    let region = parseRegion(title); 
    let nameMatch = title.match(/\]\s*([^\[\]\(]*)/); 
    let name = nameMatch ? nameMatch[1].trim() : "å®¢æˆ¶";
    let displayContent = region ? `[${region}]${name}` : title;
    let extraMatch = title.match(/(\(.*\))/); 
    if (extraMatch) displayContent += `${extraMatch[1]}`;
    if (!eventsByDate[dateKey]) eventsByDate[dateKey] = {};
    if (!eventsByDate[dateKey][timeStr]) eventsByDate[dateKey][timeStr] = [];
    if (!eventsByDate[dateKey][timeStr].includes(displayContent)) eventsByDate[dateKey][timeStr].push(displayContent);
  });

  if (approvalData) {
    approvalData.forEach(s => {
      let dateKey = s.date;
      let timeStr = s.time;
      let content = `<span style="color:red; font-weight:bold;">(ç”³è«‹ä¸­: é †ä½${s.priority})</span>`;
      if (!eventsByDate[dateKey]) eventsByDate[dateKey] = {};
      if (!eventsByDate[dateKey][timeStr]) eventsByDate[dateKey][timeStr] = [];
      eventsByDate[dateKey][timeStr].push(content);
    });
  }

  let html = '<table style="border-collapse:collapse; width:100%; table-layout:fixed; font-size:14px; border:1px solid #ccc;"><tr style="background:#eee; text-align:center;">';
  const weeks = ['æ—¥','ä¸€','äºŒ','ä¸‰','å››','äº”','å…­'];
  weeks.forEach(w => html += `<th style="border:1px solid #ccc; padding:8px;">${w}</th>`);
  html += '</tr>';
  let currentDay = new Date(startDate);
  let firstDayIndex = currentDay.getDay(); 
  html += '<tr>';
  for(let i=0; i<firstDayIndex; i++) html += '<td style="border:1px solid #ccc; background:#f9f9f9;"></td>';
  for(let i=0; i<30; i++) {
    if (currentDay.getDay() === 0 && i > 0) html += '</tr><tr>';
    let dateKey = Utilities.formatDate(currentDay, 'Asia/Taipei', 'yyyy-MM-dd');
    let dateLabel = Utilities.formatDate(currentDay, 'Asia/Taipei', 'M/d');
    let eventsHtml = '';
    let isPendingDay = false; 
    if (eventsByDate[dateKey]) {
        let sortedTimes = Object.keys(eventsByDate[dateKey]).sort();
        sortedTimes.forEach(time => {
            let checkKey = `${dateKey} ${time}`;
            let isPendingTime = pendingSet.has(checkKey);
            let timeStyle = isPendingTime ? "background:#ffcccc; color:red; border:1px solid red;" : "background:#e8f0fe; color:black;";
            if (isPendingTime) isPendingDay = true;
            eventsHtml += `<div style="${timeStyle} padding:2px 4px; margin-bottom:2px; font-weight:bold; border-radius:3px;">${time}</div>`;
            eventsByDate[dateKey][time].forEach(item => {
                eventsHtml += `<div style="padding-left:4px; margin-bottom:4px; color:#333; font-size:12px;">${item}</div>`;
            });
        });
    }
    let cellStyle = isPendingDay ? "border: 2px solid red; background:#fff5f5;" : "border:1px solid #ccc;";
    if (i===0 && !isPendingDay) cellStyle += "background:#fffde7;"; 
    html += `<td style="${cellStyle} vertical-align:top; padding:4px; height:100px;"><div style="text-align:right; font-weight:bold; color:#666; border-bottom:1px dashed #eee; margin-bottom:4px;">${dateLabel}</div>${eventsHtml}</td>`;
    currentDay.setDate(currentDay.getDate() + 1);
  }
  let actualLastDay = new Date(currentDay); actualLastDay.setDate(actualLastDay.getDate() - 1);
  let lastDayWeek = actualLastDay.getDay();
  if (lastDayWeek < 6) { for(let k=lastDayWeek + 1; k<=6; k++) html += '<td style="border:1px solid #ccc; background:#f9f9f9;"></td>'; }
  html += '</tr></table>';
  return html;
}

function createHtmlOutput(message, type) {
  let color = type === 'success' ? '#28a745' : (type === 'error' ? '#dc3545' : '#ffc107');
  let icon = type === 'success' ? 'âœ…' : (type === 'error' ? 'âŒ' : 'âš ï¸');
  let html = `<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width, initial-scale=1.0"><style>body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; background: #f8f9fa; } .card { background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); text-align: center; max-width: 90%; } .icon { font-size: 50px; margin-bottom: 20px; } .msg { font-size: 18px; line-height: 1.5; color: #333; } .close { margin-top: 20px; display: inline-block; padding: 10px 20px; background: #007bff; color: white; text-decoration: none; border-radius: 5px; }</style></head><body><div class="card"><div class="icon">${icon}</div><div class="msg" style="color:${color}">${message}</div><p><a href="#" onclick="window.close();" class="close">é—œé–‰è¦–çª—</a></p></div></body></html>`;
  return HtmlService.createHtmlOutput(html).setXFrameOptionsMode(HtmlService.XFrameOptionsMode.ALLOWALL).addMetaTag('viewport', 'width=device-width, initial-scale=1');
}

function updateSheetStatusByOrderId(targetOrderId, approvedDate, approvedTime, actionType) {
  const sheet = SpreadsheetApp.openById(SHEET_ID).getSheets()[0];
  const lastRow = sheet.getLastRow();
  if (lastRow < 2) return null;
  const data = sheet.getRange(2, 1, lastRow - 1, 15).getValues();
  let foundUserId = null;
  for(let i = 0; i < data.length; i++) {
    let rowOrderId = String(data[i][0]);
    if (rowOrderId === String(targetOrderId)) {
      let currentStatus = data[i][10];
      if (currentStatus === 'å·²æ ¸å‡†' || currentStatus === 'å·²æ‹’çµ•') return 'ALREADY_APPROVED';
    }
  }
  for(let i = 0; i < data.length; i++) {
    let rowOrderId = String(data[i][0]);
    if (rowOrderId === String(targetOrderId)) {
      let newStatus = '';
      if (actionType === 'reject_all') newStatus = 'å·²æ‹’çµ•';
      else if (actionType === 'approve') {
        let rawDate = data[i][3];
        let rowTime = String(data[i][4]);
        let rowDateStr = (rawDate instanceof Date) ? Utilities.formatDate(rawDate, 'Asia/Taipei', 'yyyy-MM-dd') : String(rawDate).replace(/'/g, '').trim();
        if (rowDateStr === approvedDate && rowTime.includes(approvedTime)) newStatus = 'å·²æ ¸å‡†';
        else newStatus = 'è‡ªå‹•å–æ¶ˆ';
      }
      if (newStatus) sheet.getRange(i + 2, 11).setValue(newStatus);
      if (!foundUserId && data[i][12]) foundUserId = data[i][12];
    }
  }
  return foundUserId;
}

function pushLineMessage(userId, text) {
  if (!userId || userId === 'Guest' || !LINE_CHANNEL_TOKEN) return false;
  try {
    UrlFetchApp.fetch('https://api.line.me/v2/bot/message/push', {
      'method': 'post',
      'headers': { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + LINE_CHANNEL_TOKEN },
      'payload': JSON.stringify({ to: userId, messages: [{ type: 'text', text: text }] }),
      'muteHttpExceptions': true 
    });
    return true;
  } catch(e) { return false; }
}

function pushLineFlexMessage(userId, altText, date, time, region, summary, calLink) {
  if (!userId || userId === 'Guest' || !LINE_CHANNEL_TOKEN) return false;
  const flexJson = {
    "type": "flex",
    "altText": altText,
    "contents": {
      "type": "bubble",
      "body": {
        "type": "box",
        "layout": "vertical",
        "contents": [
          { "type": "text", "text": "é ç´„ç¢ºèªé€šçŸ¥", "weight": "bold", "color": "#1DB446", "size": "sm" },
          { "type": "text", "text": "è¦ªæ„›çš„å®¢æˆ¶ï¼Œæ‚¨çš„é ç´„å·²ç¢ºèªï¼", "weight": "bold", "size": "md", "margin": "md", "wrap": true },
          { "type": "separator", "margin": "lg" },
          { "type": "box", "layout": "vertical", "margin": "lg", "spacing": "sm", "contents": [
              { "type": "box", "layout": "baseline", "contents": [ { "type": "text", "text": "ğŸ“… æ—¥æœŸ", "color": "#aaaaaa", "size": "sm", "flex": 2 }, { "type": "text", "text": date, "wrap": true, "color": "#666666", "size": "sm", "flex": 5 } ] },
              { "type": "box", "layout": "baseline", "contents": [ { "type": "text", "text": "ğŸ•’ æ™‚é–“", "color": "#aaaaaa", "size": "sm", "flex": 2 }, { "type": "text", "text": time, "wrap": true, "color": "#666666", "size": "sm", "flex": 5 } ] },
              { "type": "box", "layout": "baseline", "contents": [ { "type": "text", "text": "ğŸ“ åœ°é»", "color": "#aaaaaa", "size": "sm", "flex": 2 }, { "type": "text", "text": region, "wrap": true, "color": "#666666", "size": "sm", "flex": 5 } ] },
              { "type": "box", "layout": "baseline", "contents": [ { "type": "text", "text": "ğŸ› ï¸ é …ç›®", "color": "#aaaaaa", "size": "sm", "flex": 2 }, { "type": "text", "text": summary || "è©³è¦‹è¨‚å–®", "wrap": true, "color": "#666666", "size": "sm", "flex": 5 } ] }
          ] },
          { "type": "separator", "margin": "lg" }
        ]
      },
      "footer": {
        "type": "box",
        "layout": "vertical",
        "spacing": "sm",
        "contents": [
          { "type": "button", "style": "primary", "height": "sm", "action": { "type": "uri", "label": "åŠ å…¥è¡Œäº‹æ›†", "uri": calLink }, "color": "#1DB446" },
          { "type": "text", "text": "å¸«å‚…å°‡æ–¼ç•¶å¤©æº–æ™‚æŠµé”ï¼Œæ„Ÿè¬æ‚¨çš„é ç´„ï¼", "size": "xs", "color": "#aaaaaa", "align": "center", "margin": "md" }
        ],
        "flex": 0
      }
    }
  };
  try {
    UrlFetchApp.fetch('https://api.line.me/v2/bot/message/push', {
      'method': 'post',
      'headers': { 'Content-Type': 'application/json', 'Authorization': 'Bearer ' + LINE_CHANNEL_TOKEN },
      'payload': JSON.stringify({ to: userId, messages: [flexJson] }),
      'muteHttpExceptions': true 
    });
    return true;
  } catch(e) { return false; }
}
